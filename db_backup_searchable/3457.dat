bdc_function_list	\n\ncreate or replace view bdc_function_list\nas\n-- only lip functions\nselect t.routine_name::name, \nt.specific_name::name, \nt.type_udt_name::name\nfrom information_schema.routines t\nwhere t.routine_schema='lip' and t.routine_type='FUNCTION'\norder by t.routine_name\n\n
bdc_function_drop	\n\ncreate or replace function bdc_function_drop(i_name name)\nreturns text\nas $function$\n-- drop all function overloads with given i_name regardless of function parameters\n-- test it, create the function test1() and then drop it: \n-- CREATE FUNCTION test1(i integer) RETURNS integer AS $x$ BEGIN RETURN i + 1; END; $x$ LANGUAGE plpgsql;\n-- select bdc_function_drop('test1');   \ndeclare\n   v_sql text;\n   v_functions_dropped int;\nbegin\n   select count(*)::int\n        , 'DROP function ' || string_agg(p.oid::regprocedure::text, '; DROP function ')\n   from   pg_catalog.pg_proc p\n   where  p.proname = i_name\n   and p.pronamespace::regnamespace::text='lip'\n   -- count only returned if subsequent DROPs succeed  \n   into   v_functions_dropped, v_sql;\n\n   -- only if function(s) found\n   if v_functions_dropped > 0 then\n     execute v_sql;\n     return v_sql;\n   end if;\n   return '';\n\nend; $function$ language plpgsql;\n\n
bdc_view_list	\n\ncreate or replace view bdc_view_list\nas\n-- only lip views\n-- select * from bdc_view_list ;\n\nselect t.table_name::name as view_name\nfrom information_schema.views t\nwhere t.table_schema='lip'\norder by t.table_name;\n\n
bdd_table.upsert	create or replace function "bdd_table.upsert"(i_table_name name, i_notes text)\nreturns text \nas $function$\n-- Update or insert function into bdd_table table.\n-- select "bdd_table.upsert"('bdd_view','')\ndeclare\n    v_id_bdd_table integer;\n    v_text text;\nbegin\n\n    select p.id_bdd_table\n    from   bdd_table p\n    where  p.table_name = i_table_name\n    into v_id_bdd_table;\n\n    if v_id_bdd_table is null THEN\n        select "bdd_table.insert"(i_table_name, i_notes) into v_text;\n        return format('%s',v_text);\n    else\n        select "bdd_table.update"(i_table_name, i_notes) into v_text;\n        return format('%s',v_text);\n    end if;\nend; $function$ language plpgsql;
bdc_role_list	create or replace view "bdc_role_list"\nas\n-- select * from "bdc_role_list" ;\nselect usename as role_name,\n  case\n     when usesuper and usecreatedb then\n       cast('superuser, create database' as pg_catalog.text)\n     when usesuper then\n        cast('superuser' as pg_catalog.text)\n     when usecreatedb then\n        cast('create database' as pg_catalog.text)\n     else\n        cast('' as pg_catalog.text)\n  end role_attributes\nfrom pg_catalog.pg_user\norder by role_name desc;
bdd_table.insert	create or replace function "bdd_table.insert"(i_table_name name, i_notes text)\nreturns text \nas $function$\n-- insert into bdd_table table.\n-- select "bdd_table.insert"('bdd_view2','')\ndeclare\n    v_id_bdd_table integer;\n    v_text text;\n    v_record record;\nbegin\n    insert into bdd_table ( id_bdd_table, table_name, notes )\n    values ( bdc_random_int(), i_table_name, i_notes )\n    returning *\n    into v_record;\n\n    return format('Table inserted %s %s',v_record.id_bdd_table, i_table_name);\n\nend; $function$ language plpgsql;
bdd_table.update	create or replace function "bdd_table.update"(i_table_name name, i_notes text)\nreturns text \nas $function$\n-- update into bdd_table table.\n-- select "bdd_table.update"('bdd_view','')\ndeclare\n    v_record record;\nbegin\n    update bdd_table \n    set notes=i_notes\n    where table_name=i_table_name\n    returning *\n    into v_record;\n\n    return format('Table updated %s %s',v_record.id_bdd_table, i_table_name);\n\nend; $function$ language plpgsql;
bdc_table_list	create or replace view "bdc_table_list"\nas\n-- only lip tables\n-- select * from "bdc_table_list" ;\n\nselect\n  t.table_name\nfrom\n  information_schema.tables t\nwhere t.table_schema='lip'\nand table_type='BASE TABLE'
bdd_view.upsert	create or replace function "bdd_view.upsert"(i_view_name name, i_source_code text, i_notes text)\nreturns text \nas $function$\n-- Update or insert function into bdd_view table.\n-- select "bdd_view.upsert"('bdd_view','')\ndeclare\n    v_id_bdd_view integer;\n    v_text text;\nbegin\n\n    select p.id_bdd_view\n    from   bdd_view p\n    where  p.view_name = i_view_name\n    into v_id_bdd_view;\n\n    if v_id_bdd_view is null THEN\n        select "bdd_view.insert"(i_view_name, i_source_code, i_notes) into v_text;\n        return format('%s',v_text);\n    else\n        select "bdd_view.update"(i_view_name, i_source_code, i_notes) into v_text;\n        return format('%s',v_text);\n    end if;\nend; $function$ language plpgsql;
bdc_constraint_check_single_column_list	create or replace view "bdc_constraint_check_single_column_list"\nas\n-- only lip views\n-- select * from "bdc_constraint_check_single_column_list" ;\nselect tc.table_name, tc.constraint_name, col.column_name, cc.check_clause\nfrom information_schema.table_constraints tc\njoin information_schema.check_constraints cc on cc.constraint_name = tc.constraint_name\njoin pg_constraint pgc on pgc.conname = cc.constraint_name and pgc.contype = 'c' and array_length(pgc.conkey, 1) = 1\njoin information_schema.columns col on col.table_schema = tc.table_schema and col.table_name = tc.table_name and col.ordinal_position = ANY(pgc.conkey)\nwhere tc.table_schema='lip' and tc.constraint_type='CHECK'
bdc_field_table_list	create or replace view "bdc_field_table_list"\nas\n-- only lip tables\n-- select * from "bdc_field_table_list"\nselect\n    t.table_name,\n    t.column_name,\n    t.data_type,\n    t.character_maximum_length,\n    t.numeric_precision,\n    t.is_nullable,\n    t.column_default,\n    c.check_clause,\n    c.constraint_name as check_constraint_name\n    \nfrom information_schema.columns t   \nleft join bdc_constraint_check_single_column_list c on c.table_name=t.table_name and c.column_name=t.column_name\nwhere t.table_schema='lip'\norder by t.table_name, t.column_name
bdd_view.insert	create or replace function "bdd_view.insert"(i_view_name name, i_source_code text, i_notes text)\nreturns text \nas $function$\n-- insert into bdd_view table.\n-- select "bdd_view.insert"('bdd_view2','','')\ndeclare\n    v_id_bdd_view integer;\n    v_text text;\n    v_record record;\nbegin\n    insert into bdd_view ( id_bdd_view, view_name, source_code, notes )\n    values ( bdc_random_int(), i_view_name, i_source_code, i_notes )\n    returning *\n    into v_record;\n\n    return format('Table inserted %s %s',v_record.id_bdd_view, i_view_name);\n\nend; $function$ language plpgsql;
bdd_view.update	create or replace function "bdd_view.update"(i_view_name name, i_source_code text, i_notes text)\nreturns text \nas $function$\n-- update bdd_view table.\n-- select "bdd_view.update"('bdd_view','')\ndeclare\n    v_record record;\nbegin\n    update bdd_view \n    set source_code=i_source_code, notes=i_notes\n    where view_name=i_view_name\n    returning *\n    into v_record;\n\n    return format('Table updated %s %s',v_record.id_bdd_view, i_view_name);\n\nend; $function$ language plpgsql;
bdd_view.upsert_and_migrate	create or replace function "bdd_view.upsert_and_migrate"(i_source_code text, i_notes text)\nreturns text\nas $function$\n-- Update or insert view into bdd_view table. \n-- select "bdd_view.upsert_and_migrate"('create or replace view "aa123.456_789"() returns text as $x$ begin end;$x$ language plpgsql;');\ndeclare\n    v_id_bdd_view integer;\n    v_text text;\n    v_text2 text;\n    v_temp_source_code text;\n    v_pos_first integer;\n    v_pos_second integer;\n    v_prefix text='create or replace view "';\n    v_view_name name;\n    is_valid_name boolean;\nbegin\n    -- parse the source code to extract the view name\n    -- the source code must always start with \n    -- [create or replace view "view_name"]\n    -- the double quote delimiters are mandatory\n\n    select bdc_trim_whitespace(i_source_code) into v_temp_source_code;\n    if not starts_with(v_temp_source_code,v_prefix) then\n        raise exception 'Error: view_name cannot be parsed and extracted from source_code! The view code must start with [create or replace view "]. The double quotes are mandatory.';\n    end if;\n\n    -- find the second double quote to extract the view_name\n    select length(v_prefix)+1 into v_pos_first;\n    select position('"' in substring(v_temp_source_code, v_pos_first ,1000))-1+v_pos_first into v_pos_second;\n    select substring(v_temp_source_code,v_pos_first,v_pos_second-v_pos_first) into v_view_name;\n    raise notice 'view_name: %', v_view_name;\n    -- regex check: view names can have only lowercase letters, numerics, _ and dot.\n    SELECT v_view_name ~ '^[a-z0-9_\\.]*$' into is_valid_name;\n    if is_valid_name = false then\n        raise exception 'Error: Only lowercase letters, numerics, underscore and dot are allowed for view_name: %', v_view_name;        raise exception 'regex is ok';  \n    end if;\n\n    select "bdd_view.upsert"(v_view_name, v_temp_source_code, i_notes) into v_text;\n    select "bdd_view.migrate"(v_view_name) into v_text2;\n\n    return format(E'%s\\n%s', v_text2, v_text);\nend; $function$ language plpgsql;
bdd_table.migrate	create or replace function "bdd_table.migrate"(i_table_name name)\nreturns text \nas $function$\n-- checks if the table has all the fields\n-- if needed it adds the fields \n-- select * from "bdd_table.migrate"('test1')\ndeclare\n    v_row record;\n    v_sql text;\n    v_sql_fields text;\n    v_void text;\n    v_id_bdd_table integer;\nbegin\n    -- set the variable for id_bdd_table\n    -- the expression will set the variables to NULL if no rows were returned\n    select t.id_bdd_table from bdd_table t where t.table_name = i_table_name into v_id_bdd_table;\n    if v_id_bdd_table is null then\n        -- early return\n        return format('Error: Definition for %s is not in bdd_table.', i_table_name);\n    end if;\n\n    RAISE NOTICE 'Found definition for %s in bdd_table', i_table_name;\n\n    if not exists(select * from bdc_table_list a where a.table_name=i_table_name) then\n        -- if table not exists, create it with all fields in one go.\n        -- prepare code for fields\n        FOR v_row IN\n            select f.field_name, f.data_type, f.not_null, f.default_constraint, f.check_constraint\n            from bdd_field_table f\n            where f.jid_bdd_table = v_id_bdd_table\n        LOOP\n            if v_sql_fields != '' then\n                v_sql_fields = format(E'%s ,\\n', v_sql_fields);\n            end if;\n            v_sql_fields = format('%s %s %s %s %s %s', v_sql_fields, v_row.field_name, v_row.data_type, v_row.not_null, v_row.default_constraint, v_row.check_constraint);\n\n        END LOOP;\n\n        v_sql = format(E'create table %s (\\n%s\\n)', i_table_name, v_sql_fields);\n        execute v_sql;\n\n        return format(E'executed sql code:\\n%s', v_sql);\n    else\n        -- table exists, what fields don't exist?\n        -- prepare code for missing fields\n        FOR v_row IN\n            select f.field_name, f.data_type, f.not_null, f.default_constraint, f.check_constraint\n            from bdd_field_table f\n            where f.jid_bdd_table = v_id_bdd_table\n            and not exists(select * from bdc_field_table_list c where c.table_name=i_table_name and c.column_name=f.field_name)\n            \n        LOOP\n            if v_sql_fields != '' then\n                v_sql_fields = format(E'%s ,\\n', v_sql_fields);\n            end if;\n            v_sql_fields = format('add column %s %s %s %s %s %s', v_sql_fields, v_row.field_name, v_row.data_type, v_row.not_null, v_row.default_constraint, v_row.check_constraint);\n\n        END LOOP;\n\n        v_sql = format(E'alter table %s \\n%s\\n;', i_table_name, v_sql_fields);\n        execute v_sql;\n        return format(E'executed sql code:\\n%s', v_sql);\n    end if;\n\nend; $function$ language plpgsql;
bdd_function.upsert_and_migrate	create or replace function "bdd_function.upsert_and_migrate"(i_source_code text)\nreturns text\nas $function$\n-- Update or insert function into bdd_function table. \n-- select "bdd_function.upsert_and_migrate"('create or replace function "aa123.456_789"() returns text as $x$ begin end;$x$ language plpgsql;');\ndeclare\n    v_id_bdd_function integer;\n    v_text text;\n    v_text2 text;\n    v_temp_source_code text;\n    v_pos_first integer;\n    v_pos_second integer;\n    v_prefix text='create or replace function "';\n    v_function_name name;\n    is_valid_name boolean;\nbegin\n    -- parse the source code to extract the function name\n    -- the source code must always start with \n    -- [create or replace function "function_name"]\n    -- the double quote delimiters are mandatory\n\n    select bdc_trim_whitespace(i_source_code) into v_temp_source_code;\n    if not starts_with(v_temp_source_code,v_prefix) then\n        raise exception 'Error: function_name cannot be parsed and extracted from source_code! The function code must start with [create or replace function "]. The double quotes are mandatory.';\n    end if;\n\n    -- find the second double quote to extract the function_name\n    select length(v_prefix)+1 into v_pos_first;\n    select position('"' in substring(v_temp_source_code, v_pos_first ,1000))-1+v_pos_first into v_pos_second;\n    select substring(v_temp_source_code,v_pos_first,v_pos_second-v_pos_first) into v_function_name;\n    raise notice 'function_name: %', v_function_name;\n    -- regex check: function names can have only lowercase letters, numerics, _ and dot.\n    SELECT v_function_name ~ '^[a-z0-9_\\.]*$' into is_valid_name;\n    if is_valid_name = false then\n        raise exception 'Error: Only lowercase letters, numerics, underscore and dot are allowed for function_name: %', v_function_name;        raise exception 'regex is ok';  \n    end if;\n\n    select "bdd_function.upsert"(v_function_name, v_temp_source_code) into v_text;\n    select "bdd_function.migrate"(v_function_name) into v_text2;\n\n    return format(E'%s\\n%s', v_text2, v_text);\nend; $function$ language plpgsql;
bdc_strip_prefix	create or replace function "bdc_strip_prefix"(i_string text, i_prefix text)\nreturns text \nas $function$\n-- Returns a string with the prefix removed\n-- select bdc_strip_prefix('123456789','123')\n-- select bdc_strip_prefix('123456789','1')\n-- select bdc_strip_prefix('123456789','') - returns the same string\n-- select bdc_strip_prefix('123456789','999') - returns the same string\n-- select bdc_strip_prefix('123456789','123456789') - returns empty string\n-- select bdc_strip_prefix('12345','123456789') - returns the same string\n-- select bdc_strip_prefix('123456789',null) - returns the same string\n-- select bdc_strip_prefix(null,'123') - returns null\nbegin\nif starts_with(i_string, i_prefix) then\n    return substring(i_string, length(i_prefix)+1);\nelse\n    return i_string;\nend if;\n\nend; $function$ language plpgsql;
bdc_view_migrate	create or replace function bdc_view_migrate(i_object_name name, i_source_code text)\nreturns text \nas $function$\n-- checks if the view is already installed and if the bdc_source_code is different\n-- if is equal, nothing happens\n-- else drop the old and install the new view\n-- finally insert/update into bdc_source_code  \ndeclare\n   v_old_source_code text;\n   v_sql text;\nbegin\n\n   if not exists(select * from bdc_source_code a where a.object_name = i_object_name) then\n      if exists(select * from bdc_view_list v where v.view_name=i_object_name) then\n         v_sql = format('drop view %i cascade', i_object_name);\n         RAISE '%s', v_sql;\n         execute v_sql;\n      end if;\n\n      execute i_source_code;\n\n      insert into bdc_source_code (object_name, source_code)\n      values (i_object_name, i_source_code);\n\n      return format('Inserted view: %I', i_object_name);\n   else\n      select a.source_code \n      from bdc_source_code a\n      where a.object_name = i_object_name\n      into v_old_source_code;\n\n      if i_source_code <> v_old_source_code then\n         if exists(select * from bdc_view_list v where v.view_name=i_object_name) then\n            execute format('DROP VIEW %I CASCADE', i_object_name);\n         end if;\n      else\n         return format('View is up to date: %I', i_object_name);\n      end if;\n\n      if not exists(select * from bdc_view_list v where v.view_name=i_object_name) then\n         execute i_source_code;\n\n         update bdc_source_code s\n         set source_code = i_source_code\n         where s.object_name = i_object_name;\n\n         return format('Updated view: %I', i_object_name);\n      end if;\n   end if;\n\nend; $function$ language plpgsql;
bdd_field_table.details	create or replace view "bdd_field_table.details"\nas\n-- more details for field definitions are used to compare with the postgres definition\n-- select * from "bdd_field_table.details" ;\n\nselect t.table_name, f.field_name, \n-- data_type\nf.data_type,\nf.data_type as data_type_formatted,\ncase when c.data_type='character varying' then format('varchar(%s)', c.character_maximum_length)\nelse c.data_type\nend as bdc_data_type_formatted,\n-- not null\nf.not_null,\nf.not_null as not_null_formatted, \ncase when c.is_nullable='YES' then ''\nelse 'not null'\nend as bdc_is_nullable_formatted,\n-- default constraint\nf.default_constraint,\ncase \n    when f.default_constraint='' then ''\n    else format('%s',bdc_strip_prefix(f.default_constraint,'default '))\nend as default_constraint_formatted,\nreplace(replace(coalesce(c.column_default,''), '::character varying', ''),'::text','') as bdc_column_default_formatted,\n-- check constraint\nf.check_constraint,\ncase \n    when f.check_constraint='' then ''\n    else format('(%s)',bdc_strip_prefix(f.check_constraint,'check '))\nend as check_constraint_formatted,\ncoalesce(c.check_clause,'') as bdc_check_clause_formatted,\nc.check_constraint_name\n\nfrom bdd_table t\njoin bdd_field_table f on f.jid_bdd_table=t.id_bdd_table\njoin bdc_field_table_list c on c.table_name=t.table_name and c.column_name=f.field_name
bdd_function.migrate	create or replace function "bdd_function.migrate"(i_function_name name)\nreturns text \nas $function$\n-- install the function from bdd into postgres\n-- if the function is modified\n-- select "bdd_function.migrate"('bdc_function_drop')\ndeclare\n    v_source_code text;\n    v_text text;\nbegin\n\nselect f.source_code from bdd_function f where f.function_name=i_function_name into v_source_code;\n\nselect bdc_function_migrate from bdc_function_migrate(i_function_name, v_source_code) into v_text;\n\nreturn v_text;\nend; $function$ language plpgsql;
bdd_table.migrate_details	create or replace function "bdd_table.migrate_details"(i_table_name name)\nreturns text \nas $function$\n-- checks if the the table fields have the same details in the database as in the definition: \n-- data_type, not_null, check_constraint, default_constraint\n-- select * from "bdd_table.migrate_details"('test1')\ndeclare\n    v_row record;\n    v_sql text;\n    v_sql_field text;\n    v_void text;\n    v_id_bdd_table integer;\nbegin\n    -- set the variable for id_bdd_table\n    -- the expression will set the variables to NULL if no rows were returned\n    select t.id_bdd_table from bdd_table t where t.table_name = i_table_name into v_id_bdd_table;\n    if v_id_bdd_table is null then\n        -- early return\n        return format('Error: Definition for %s is not in bdd_table.', i_table_name);\n    end if;\n\n    FOR v_row IN\n        select f.table_name, f.field_name, f.data_type\n        from "bdd_field_table.details" f\n        where f.table_name= i_table_name and \n        f.data_type_formatted != f.bdc_data_type_formatted\n    LOOP\n        v_sql_field = format(E'alter table %I alter column %I type %s;',i_table_name, v_row.field_name, v_row.data_type);\n        v_sql = format (E'%s\\n%s',v_sql, v_sql_field);\n        -- printing before execute will show where eas the error\n        raise debug '%', v_sql_field;\n        -- execute v_sql_field;\n    END LOOP;\n\n    FOR v_row IN\n        select f.table_name, f.field_name, f.not_null\n        from "bdd_field_table.details" f\n        where f.table_name= i_table_name and \n        f.not_null_formatted != f.bdc_is_nullable_formatted\n    LOOP\n        if v_row.not_null = '' THEN\n            v_sql_field = format(E'alter table %I alter column %I drop not null;',i_table_name, v_row.field_name);\n        ELSE\n            v_sql_field = format(E'alter table %I alter column %I set not null;',i_table_name, v_row.field_name);\n        end if;\n        v_sql = format (E'%s\\n%s',v_sql, v_sql_field);\n        -- printing before execute will show where eas the error\n        raise debug '%', v_sql_field;\n        -- execute v_sql_field;\n    END LOOP;\n\n    FOR v_row IN\n        select f.table_name, f.field_name, f.default_constraint\n        from "bdd_field_table.details" f\n        where f.table_name= i_table_name and \n        f.default_constraint_formatted != f.bdc_column_default_formatted\n    LOOP\n        if v_row.default_constraint = '' then\n            v_sql_field = format(E'alter table %I alter column %I drop default;',i_table_name, v_row.field_name);\n        else\n            v_sql_field = format(E'alter table %I alter column %I set %s;',i_table_name, v_row.field_name, v_row.default_constraint);\n        end if;\n        v_sql = format (E'%s\\n%s',v_sql, v_sql_field);\n        -- printing before execute will show where eas the error\n        raise debug '%', v_sql_field;\n        -- execute v_sql_field;\n    END LOOP;\n\n    FOR v_row IN\n        select f.table_name, f.field_name, f.check_constraint, f.check_constraint_name\n        from "bdd_field_table.details" f\n        where f.table_name= i_table_name and \n        f.check_constraint_formatted != f.bdc_check_clause_formatted\n    LOOP\n        if v_row.check_constraint = '' then\n            v_sql_field = format(E'alter table %I alter column %I drop constraint %s;',i_table_name, v_row.field_name, v_row.check_constraint_name);\n        else\n            v_sql_field = format(E'alter table %I add %s;',i_table_name, v_row.check_constraint);\n        end if;\n        v_sql = format (E'%s\\n%s',v_sql, v_sql_field);\n        -- printing before execute will show where eas the error\n        raise debug '%', v_sql_field;\n        -- execute v_sql_field;\n    END LOOP;\n    return format(E'executed sql code:\\n%s', v_sql);\n\nend; $function$ language plpgsql;
bdc_random_int	create or replace function bdc_random_int()\nreturns integer\n-- inline scalar function ( must be sql language)\n-- random from 1 to 2147483646, \n-- that is max positive for the data type integer\n-- select bdc_random_int() as my_random;\n-- EXPLAIN (ANALYZE, VERBOSE) SELECT bdc_random_int(),table_name as my_random FROM bdd_table;\nas $function$\n    select FLOOR(RANDOM()*2147483646::double precision) + 1;\n$function$ language sql;
bdc_trim_whitespace	create or replace function bdc_trim_whitespace(i_string text)\nreturns text\n-- trim space, newline and tab on both ends\n-- select bdc_trim_whitespace() as my_random;\n-- select bdc_trim_whitespace(' 123 ');\nas $function$\n    SELECT trim(i_string,E' \\n\\r\\t'); \n$function$ language sql;
bdc_function_drop_overloads	create or replace function bdc_function_drop_overloads(i_function_name name)\nreturns text\nas $function$\n-- Postgres has this terrible concept of function overloading.\n-- I want to have only one function with the same name for sake of my sanity.\n-- After `create or replace` I will drop all other overloads.\n-- I will leave only the function with the biggest oid number, because that is tha last I installed.\n-- My first try was to drop the function before recreating it, \n-- but Postgres does not allow if the function is already been used in a dependent object.\n-- test it, create the function test1() and then drop it: \n-- CREATE FUNCTION test1(i integer) RETURNS integer AS $x$ BEGIN RETURN i + 1; END; $x$ LANGUAGE plpgsql;\n-- select bdc_function_drop_overloads('test1');   \ndeclare\n    v_sql text;\n    v_functions_dropped int;\n    v_last_oid int;\nbegin\n    -- the last oib is the last installed function variant and it will remain. \n    -- All older will be dropped.\n    select max(p.oid)\n    from   pg_catalog.pg_proc p\n    where  p.proname = i_function_name\n    and p.pronamespace::regnamespace::text='lip'\n    into   v_last_oid; \n\n    select count(*)::int, 'DROP function ' || string_agg(p.oid::regprocedure::text, '; DROP function ')\n    from   pg_catalog.pg_proc p\n    where  p.proname = i_function_name and p.oid < v_last_oid\n    and p.pronamespace::regnamespace::text='lip'\n    -- count only returned if subsequent DROPs succeed\n    into   v_functions_dropped, v_sql;  \n\n    -- only if function(s) found\n    if v_functions_dropped > 0 then\n        execute v_sql;\n        return v_sql;\n    end if;\n    return '';\n\nend; $function$ language plpgsql;\n\n
bdc_function_migrate	create or replace function bdc_function_migrate(i_function_name name, i_source_code text)\nreturns text \nas $function$\n-- checks if the function is already installed and if the content of bdc_source_code is different\n-- if is equal, nothing happens\n-- else drop the old and install the new function\n-- finally insert/update into bdc_source_code only if the installation is successful  \ndeclare\n   v_old_source_code text;\n   v_void text;\nbegin\n\n   if not exists(select * from bdc_source_code a where a.object_name = i_function_name) then\n      if exists(select * from bdc_function_list p where p.routine_name = i_function_name) then\n         -- must not drop functions because of the error: \n         -- cannot drop function because other objects depend on it.\n         select bdc_function_drop(i_function_name) into v_void;\n      end if;\n\n      execute i_source_code;\n\n      insert into bdc_source_code (object_name, source_code)\n      values (i_function_name, i_source_code);\n\n      select bdc_function_drop_overloads(i_function_name) into v_void;\n\n      return format('Inserted function: %I', i_function_name);\n   else\n      select a.source_code \n      from bdc_source_code a\n      where a.object_name = i_function_name\n      into v_old_source_code;\n\n      if i_source_code <> v_old_source_code then\n         \n         execute i_source_code;\n\n         update bdc_source_code s\n         set source_code = i_source_code\n         where s.object_name = i_function_name;\n\n         select bdc_function_drop_overloads(i_function_name) into v_void;\n\n         return format('Updated function: %I', i_function_name);\n      else\n         return format('Function is up to date: %I', i_function_name);\n      end if;\n\n   end if;\n\nend; $function$ language plpgsql;
bdd_function.upsert	create or replace function "bdd_function.upsert"(i_function_name name, i_source_code text)\nreturns text\nas $function$\n-- Update or insert function into bdd_function table. \ndeclare\n    v_id_bdd_function integer;\n    v_text text;\nbegin\n\n    if not starts_with(bdc_trim_whitespace(i_source_code), format('create or replace function %I', i_function_name)) then\n        return format('Error: %s function name is not right.', i_function_name);\n    end if;\n\n    select p.id_bdd_function\n    from   bdd_function p\n    where  p.function_name = i_function_name\n    into v_id_bdd_function;\n\n    if v_id_bdd_function is null THEN\n\n        insert into bdd_function ( id_bdd_function, source_code, function_name )\n        values ( bdc_random_int(), bdc_trim_whitespace(i_source_code), i_function_name );\n\n        return format('Function inserted %s',i_function_name);\n    else\n\n        update bdd_function t set source_code = bdc_trim_whitespace(i_source_code)\n        where t.function_name = i_function_name;\n        \n        return format('Function updated %s',i_function_name);\n    end if;\nend; $function$ language plpgsql;
aa123.456_789	create or replace function "aa123.456_789"() returns text as $x$ begin end;$x$ language plpgsql;
bdc_function.list	create or replace view "bdc_function.list"\nas\n-- only lip functions\nselect t.routine_name::name as function_name, \nt.specific_name::name, \nt.type_udt_name::name\nfrom information_schema.routines t\nwhere t.routine_schema='lip' and t.routine_type='FUNCTION'\norder by function_name
\.


