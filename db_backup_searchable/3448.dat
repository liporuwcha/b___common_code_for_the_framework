2	create or replace function "bdc_strip_prefix"(i_string text, i_prefix text)\nreturns text \nas $function$\n-- Returns a string with the prefix removed\n-- select bdc_strip_prefix('123456789','123')\n-- select bdc_strip_prefix('123456789','1')\n-- select bdc_strip_prefix('123456789','') - returns the same string\n-- select bdc_strip_prefix('123456789','999') - returns the same string\n-- select bdc_strip_prefix('123456789','123456789') - returns empty string\n-- select bdc_strip_prefix('12345','123456789') - returns the same string\n-- select bdc_strip_prefix('123456789',null) - returns the same string\n-- select bdc_strip_prefix(null,'123') - returns null\nbegin\nif starts_with(i_string, i_prefix) then\n    return substring(i_string, length(i_prefix)+1);\nelse\n    return i_string;\nend if;\n\nend; $function$ language plpgsql;	bdc_strip_prefix
1	create or replace function bdc_function_drop(i_name name)\nreturns text\nas $function$\n-- drop all function overloads with given i_name regardless of function parameters\n-- test it, create the function test1() and then drop it: \n-- CREATE FUNCTION test1(i integer) RETURNS integer AS $x$ BEGIN RETURN i + 1; END; $x$ LANGUAGE plpgsql;\n-- select bdc_function_drop('test1');   \ndeclare\n   v_sql text;\n   v_functions_dropped int;\nbegin\n   select count(*)::int\n        , 'DROP function ' || string_agg(p.oid::regprocedure::text, '; DROP function ')\n   from   pg_catalog.pg_proc p\n   where  p.proname = i_name\n   and p.pronamespace::regnamespace::text='lip'\n   -- count only returned if subsequent DROPs succeed  \n   into   v_functions_dropped, v_sql;\n\n   -- only if function(s) found\n   if v_functions_dropped > 0 then\n     execute v_sql;\n     return v_sql;\n   end if;\n   return '';\n\nend; $function$ language plpgsql;	bdc_function_drop
731475369	create or replace function bdc_trim_whitespace(i_string text)\nreturns text\n-- trim space, newline and tab on both ends\n-- select bdc_trim_whitespace() as my_random;\n-- select bdc_trim_whitespace(' 123 ');\nas $function$\n    SELECT trim(i_string,E' \\n\\r\\t'); \n$function$ language sql;	bdc_trim_whitespace
678366353	create or replace function bdc_function_drop_overloads(i_function_name name)\nreturns text\nas $function$\n-- Postgres has this terrible concept of function overloading.\n-- I want to have only one function with the same name for sake of my sanity.\n-- After `create or replace` I will drop all other overloads.\n-- I will leave only the function with the biggest oid number, because that is tha last I installed.\n-- My first try was to drop the function before recreating it, \n-- but Postgres does not allow if the function is already been used in a dependent object.\n-- test it, create the function test1() and then drop it: \n-- CREATE FUNCTION test1(i integer) RETURNS integer AS $x$ BEGIN RETURN i + 1; END; $x$ LANGUAGE plpgsql;\n-- select bdc_function_drop_overloads('test1');   \ndeclare\n    v_sql text;\n    v_functions_dropped int;\n    v_last_oid int;\nbegin\n    -- the last oib is the last installed function variant and it will remain. \n    -- All older will be dropped.\n    select max(p.oid)\n    from   pg_catalog.pg_proc p\n    where  p.proname = i_function_name\n    and p.pronamespace::regnamespace::text='lip'\n    into   v_last_oid; \n\n    select count(*)::int, 'DROP function ' || string_agg(p.oid::regprocedure::text, '; DROP function ')\n    from   pg_catalog.pg_proc p\n    where  p.proname = i_function_name and p.oid < v_last_oid\n    and p.pronamespace::regnamespace::text='lip'\n    -- count only returned if subsequent DROPs succeed\n    into   v_functions_dropped, v_sql;  \n\n    -- only if function(s) found\n    if v_functions_dropped > 0 then\n        execute v_sql;\n        return v_sql;\n    end if;\n    return '';\n\nend; $function$ language plpgsql;\n\n	bdc_function_drop_overloads
316494189	create or replace function "bdd_function.upsert_and_migrate"(i_function_name name, i_source_code text)\nreturns text\nas $function$\n-- Update or insert function into bdd_function table. \ndeclare\n    v_id_bdd_function integer;\n    v_text text;\n    v_text2 text;\nbegin\n    select "bdd_function.upsert"(i_function_name, i_source_code) into v_text;\n    select "bdd_function.migrate"(i_function_name) into v_text2;\n\n    return format(E'%s\\n%s', v_text, v_text2);\nend; $function$ language plpgsql;	bdd_function.upsert_and_migrate
\.


